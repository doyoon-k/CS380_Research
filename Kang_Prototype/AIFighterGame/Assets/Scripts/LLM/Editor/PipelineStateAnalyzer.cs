using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json.Linq;
using UnityEngine;

/// <summary>
/// Editor-only helper that inspects a PromptPipelineAsset and infers which state keys each step uses or produces.
/// </summary>
public static class PipelineStateAnalyzer
{
    private static readonly Regex PromptKeyRegex = new Regex(
        "{{([A-Za-z0-9_]+)}}",
        RegexOptions.Compiled
    );

    public static AnalyzedStateModel Analyze(PromptPipelineAsset asset)
    {
        var model = new AnalyzedStateModel();
        if (asset == null || asset.steps == null)
        {
            return model;
        }

        model.stepCount = asset.steps.Count;
        var keyMap = new Dictionary<string, AnalyzedStateKey>();

        for (int i = 0; i < asset.steps.Count; i++)
        {
            var step = asset.steps[i];
            if (step == null)
            {
                continue;
            }

            switch (step.stepKind)
            {
                case PromptPipelineStepKind.JsonLlm:
                case PromptPipelineStepKind.CompletionLlm:
                    CollectPromptKeys(step, keyMap, i);
                    break;
                case PromptPipelineStepKind.CustomLink:
                    CollectCustomLinkKeys(step, keyMap, i);
                    break;
            }

            switch (step.stepKind)
            {
                case PromptPipelineStepKind.JsonLlm:
                    CollectJsonProducedKeys(step, keyMap, i);
                    break;
                case PromptPipelineStepKind.CompletionLlm:
                    model.hasCompletionStep = true;
                    RegisterKey(keyMap, PromptPipelineConstants.AnswerKey)
                        .producedByStepIndices
                        .AddUnique(i);
                    break;
            }
        }

        foreach (AnalyzedStateKey key in keyMap.Values)
        {
            bool hasProducer = key.producedByStepIndices.Count > 0;
            bool hasConsumer = key.consumedByStepIndices.Count > 0;

            if (string.Equals(key.keyName, PromptPipelineConstants.AnswerKey, StringComparison.Ordinal) &&
                model.hasCompletionStep)
            {
                key.kind = AnalyzedStateKeyKind.Output;
            }
            else if (!hasProducer && hasConsumer)
            {
                key.kind = AnalyzedStateKeyKind.Input;
            }
            else if (hasProducer && !hasConsumer)
            {
                key.kind = AnalyzedStateKeyKind.Output;
            }
            else if (hasProducer && hasConsumer)
            {
                key.kind = AnalyzedStateKeyKind.Intermediate;
            }
            else
            {
                key.kind = AnalyzedStateKeyKind.Input;
            }
        }

        model.keys = keyMap.Values
            .OrderBy(k => k.kind)
            .ThenBy(k => k.keyName, StringComparer.Ordinal)
            .ToList();

        ComputeStepStates(asset, model);

        return model;
    }

    private static void CollectPromptKeys(
        PromptPipelineStep step,
        Dictionary<string, AnalyzedStateKey> keyMap,
        int stepIndex
    )
    {
        if (!string.IsNullOrEmpty(step.userPromptTemplate))
        {
            foreach (string key in ExtractPromptKeys(step.userPromptTemplate))
            {
                RegisterKey(keyMap, key).consumedByStepIndices.AddUnique(stepIndex);
            }
        }

        var settings = step.ollamaSettings;
        if (settings != null && !string.IsNullOrEmpty(settings.systemPromptTemplate))
        {
            foreach (string key in ExtractPromptKeys(settings.systemPromptTemplate))
            {
                RegisterKey(keyMap, key).consumedByStepIndices.AddUnique(stepIndex);
            }
        }
    }

    private static void CollectCustomLinkKeys(
        PromptPipelineStep step,
        Dictionary<string, AnalyzedStateKey> keyMap,
        int stepIndex)
    {
        if (string.IsNullOrWhiteSpace(step.customLinkTypeName))
        {
            return;
        }

        if (!CustomLinkStateResolver.TryResolve(step, out var writes))
        {
            return;
        }

        foreach (string key in writes)
        {
            RegisterKey(keyMap, key).producedByStepIndices.AddUnique(stepIndex);
        }
    }

    private static void CollectJsonProducedKeys(
        PromptPipelineStep step,
        Dictionary<string, AnalyzedStateKey> keyMap,
        int stepIndex
    )
    {
        var settings = step.ollamaSettings;
        string schema = settings?.format;
        if (settings == null || string.IsNullOrWhiteSpace(schema))
        {
            return;
        }

        string trimmed = schema.TrimStart();
        if (trimmed.Length == 0 || (trimmed[0] != '{' && trimmed[0] != '['))
        {
            return;
        }

        try
        {
            var token = JToken.Parse(schema);
            foreach (string keyName in ExtractSchemaPropertyNames(token))
            {
                if (!string.IsNullOrWhiteSpace(keyName))
                {
                    RegisterKey(keyMap, keyName).producedByStepIndices.AddUnique(stepIndex);
                }
            }
        }
        catch (Exception ex)
        {
            Debug.LogWarning($"PipelineStateAnalyzer: Failed to parse JSON format for step '{step.stepName}': {ex.Message}");
        }
    }

    private static IEnumerable<string> ExtractPromptKeys(string template)
    {
        var matches = PromptKeyRegex.Matches(template);
        foreach (Match match in matches)
        {
            if (match.Groups.Count > 1)
            {
                yield return match.Groups[1].Value;
            }
        }
    }

    private static IEnumerable<string> ExtractSchemaPropertyNames(JToken token)
    {
        if (token is not JObject obj)
        {
            yield break;
        }

        if (obj.TryGetValue("properties", out var propsToken) && propsToken is JObject propsObj)
        {
            foreach (JProperty prop in propsObj.Properties())
            {
                yield return prop.Name;
            }
            yield break;
        }

        foreach (JProperty prop in obj.Properties())
        {
            yield return prop.Name;
        }
    }

    private static AnalyzedStateKey RegisterKey(Dictionary<string, AnalyzedStateKey> keyMap, string keyName)
    {
        if (!keyMap.TryGetValue(keyName, out var key))
        {
            key = new AnalyzedStateKey { keyName = keyName };
            keyMap.Add(keyName, key);
        }
        return key;
    }

    private static void ComputeStepStates(PromptPipelineAsset asset, AnalyzedStateModel model)
    {
        model.stepStates = new List<AnalyzedStepState>();
        model.finalStateKeys = new List<string>();
        if (asset == null || asset.steps == null || model.keys == null)
        {
            return;
        }

        int stepCount = asset.steps.Count;
        if (stepCount == 0)
        {
            model.finalStateKeys = model.keys
                .Where(k => k.kind == AnalyzedStateKeyKind.Input)
                .Select(k => k.keyName)
                .OrderBy(k => k, StringComparer.Ordinal)
                .ToList();
            return;
        }
        var producedByStep = new List<HashSet<string>>(stepCount);
        for (int i = 0; i < stepCount; i++)
        {
            producedByStep.Add(new HashSet<string>(StringComparer.Ordinal));
        }

        foreach (AnalyzedStateKey key in model.keys)
        {
            foreach (int idx in key.producedByStepIndices)
            {
                if (idx >= 0 && idx < stepCount)
                {
                    producedByStep[idx].Add(key.keyName);
                }
            }
        }

        var currentKeys = new HashSet<string>(
            model.keys.Where(k => k.kind == AnalyzedStateKeyKind.Input).Select(k => k.keyName),
            StringComparer.Ordinal
        );

        for (int i = 0; i < stepCount; i++)
        {
            var produced = producedByStep[i];
            var newKeys = produced.Where(k => !currentKeys.Contains(k)).OrderBy(k => k, StringComparer.Ordinal).ToList();
            foreach (string k in produced)
            {
                currentKeys.Add(k);
            }

            var snapshot = new AnalyzedStepState
            {
                stepIndex = i,
                stateKeys = currentKeys.OrderBy(k => k, StringComparer.Ordinal).ToList(),
                newKeys = newKeys
            };

            model.stepStates.Add(snapshot);
        }

        if (model.stepStates.Count > 0)
        {
            model.finalStateKeys = new List<string>(model.stepStates.Last().stateKeys);
        }
    }
}

[Serializable]
public class AnalyzedStateModel
{
    public List<AnalyzedStateKey> keys = new();
    public int stepCount;
    public bool hasCompletionStep;
    public List<AnalyzedStepState> stepStates = new();
    public List<string> finalStateKeys = new();
}

[Serializable]
public class AnalyzedStateKey
{
    public string keyName;
    public List<int> producedByStepIndices = new();
    public List<int> consumedByStepIndices = new();
    public AnalyzedStateKeyKind kind;
    public string lastValuePreview;
}

[Serializable]
public class AnalyzedStepState
{
    public int stepIndex;
    public List<string> stateKeys = new();
    public List<string> newKeys = new();
}

public enum AnalyzedStateKeyKind
{
    Input = 0,
    Intermediate = 1,
    Output = 2
}

internal static class ListExtensions
{
    public static void AddUnique(this List<int> source, int value)
    {
        if (!source.Contains(value))
        {
            source.Add(value);
        }
    }
}
