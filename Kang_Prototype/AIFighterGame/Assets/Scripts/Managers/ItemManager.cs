using UnityEngine;
using System.Collections;

public class ItemManager : MonoBehaviour
{
    [Header("Components")]
    public OllamaClient ollamaClient;
    public PlayerStats playerStats;

    [Header("Test Items")]
    public ItemData[] testItems;
    public int currentItemIndex = 0;

    [Header("Skill System")]
    public SkillManager skillManager;
    void Start()
    {
        if (ollamaClient == null)
        {
            ollamaClient = GetComponent<OllamaClient>();
        }

        Debug.Log("ItemManager initialized!");
        Debug.Log("Press '4' to use current item");
        Debug.Log("Press '5' to switch to next item");
        Debug.Log("Press '6' to clear ALL caches");
        Debug.Log("Press '7' to clear current item cache");
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha4))
        {
            if (testItems != null && testItems.Length > 0 && testItems[currentItemIndex] != null)
            {
                StartCoroutine(ApplyItem(testItems[currentItemIndex]));
            }
            else
            {
                Debug.LogError("No test items assigned!");
            }
        }

        if (Input.GetKeyDown(KeyCode.Alpha5))
        {
            if (testItems != null && testItems.Length > 0)
            {
                currentItemIndex = (currentItemIndex + 1) % testItems.Length;
                Debug.Log($"Switched to item: {testItems[currentItemIndex].itemName}");
            }
        }

        if (Input.GetKeyDown(KeyCode.Alpha6))
        {
            ClearAllCaches();
        }

        if (Input.GetKeyDown(KeyCode.Alpha7))
        {
            ClearCurrentItemCache();
        }
    }

    IEnumerator ApplyItem(ItemData item)
    {
        Debug.Log($"=== Applying Item: {item.itemName} ===");

        bool isComplete = false;
        AIResponse aiResponse = null;
        string errorMessage = null;

        yield return ollamaClient.GenerateSkillsAndStats(
            item,
            response =>
            {
                aiResponse = response;
                isComplete = true;
            },
            error =>
            {
                errorMessage = error;
                isComplete = true;
            }
        );

        yield return new WaitUntil(() => isComplete);

        if (errorMessage != null)
        {
            Debug.LogError($"Failed to generate AI content: {errorMessage}");
            yield break;
        }

        if (aiResponse != null)
        {
            ApplyStatModel(aiResponse.stat_model);
            ApplySkillModel(aiResponse.skill_model);
        }
    }

    void ApplyStatModel(StatModel statModel)
    {
        Debug.Log("=== Applying Stat Model ===");

        Stats statChanges = new Stats
        {
            Speed = statModel.stat_changes.Speed,
            Attack = statModel.stat_changes.Attack,
            Defense = statModel.stat_changes.Defense,
            Jump = statModel.stat_changes.Jump,
            Attack_Speed = statModel.stat_changes.Attack_Speed,
            Range = statModel.stat_changes.Range
        };

        playerStats.ModifyStats(statChanges, statModel.duration_seconds);
    }

    void ApplySkillModel(SkillModel skillModel)
    {
        Debug.Log("=== Applying Skill Model ===");

        if (skillModel == null)
        {
            Debug.LogWarning("Skill model is null!");
            return;
        }

        if (skillModel.new_skills == null || skillModel.new_skills.Count == 0)
        {
            Debug.LogWarning("No skills generated by AI!");
            return;
        }

        if (skillManager != null)
        {
            skillManager.ClearSkills();
        }

        foreach (var skill in skillModel.new_skills)
        {
            Debug.Log($"New Skill: {skill.name}");
            Debug.Log($"  Sequence: {string.Join(" -> ", skill.sequence)}");
            Debug.Log($"  Description: {skill.description}");
            Debug.Log($"  Cooldown: {skill.cooldown}s, Duration: {skill.duration}s");

            if (skillManager != null)
            {
                skillManager.AddSkill(skill);
            }
        }
    }

    void ClearAllCaches()
    {
        if (testItems == null || testItems.Length == 0)
        {
            Debug.LogWarning("No items to clear cache!");
            return;
        }

        int clearedCount = 0;

        foreach (ItemData item in testItems)
        {
            if (item != null)
            {
                item.isCached = false;
                item.cachedStatModelJson = "";
                item.cachedSkillModelJson = "";
                clearedCount++;

#if UNITY_EDITOR
                UnityEditor.EditorUtility.SetDirty(item);
#endif
            }
        }

#if UNITY_EDITOR
        UnityEditor.AssetDatabase.SaveAssets();
#endif

        Debug.Log($"Cleared cache for ALL {clearedCount} items!");
        Debug.Log("Press '4' to regenerate skills with AI!");
    }

    void ClearCurrentItemCache()
    {
        if (testItems == null || testItems.Length == 0 || testItems[currentItemIndex] == null)
        {
            Debug.LogWarning("No current item to clear cache!");
            return;
        }

        ItemData item = testItems[currentItemIndex];
        item.isCached = false;
        item.cachedStatModelJson = "";
        item.cachedSkillModelJson = "";

#if UNITY_EDITOR
        UnityEditor.EditorUtility.SetDirty(item);
        UnityEditor.AssetDatabase.SaveAssets();
#endif

        Debug.Log($"Cleared cache for: {item.itemName}!");
        Debug.Log("Press '4' to regenerate skills with AI!");
    }
}